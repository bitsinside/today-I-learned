# Web Vulnerability Categories

- [Web Vulnerability Categories](#web-vulnerability-categories)
  - [1. Data handling](#1-data-handling)
    - [1.1 Injection Flaws - Code injection](#11-injection-flaws---code-injection)
    - [1.2. Injection Flaws - CRLF injection](#12-injection-flaws---crlf-injection)
    - [1.3. Injection Flaws - LDAP injection](#13-injection-flaws---ldap-injection)
    - [1.4. Injection Flaws - NoSQL injection](#14-injection-flaws---nosql-injection)
    - [1.5. Injection Flaws - Path travesal](#15-injection-flaws---path-travesal)
    - [1.6. Injection Flaws - Remote file inclusion](#16-injection-flaws---remote-file-inclusion)
    - [1.7. Injection Flaws - Resource injection](#17-injection-flaws---resource-injection)
    - [1.8. Injection Flaws - OS command injection](#18-injection-flaws---os-command-injection)
    - [1.9. Injection Flaws - SQL injection](#19-injection-flaws---sql-injection)
    - [1.10. Injection Flaws - Log forging](#110-injection-flaws---log-forging)
    - [1.11. Injection - Local file inclusion](#111-injection---local-file-inclusion)
    - [1.12. Email injection](#112-email-injection)
    - [1.13. Injection Flaws - Deserialization of unstrusted data](#113-injection-flaws---deserialization-of-unstrusted-data)
    - [1.14. Injection Flaws - CSS injection](#114-injection-flaws---css-injection)
    - [1.15. Injection Flaws - XPath and XML injection](#115-injection-flaws---xpath-and-xml-injection)
    - [1.16. Unvalidated redirects and forwards](#116-unvalidated-redirects-and-forwards)
    - [1.17. Cross-Site Scripting (XSS) - Stored XSS](#117-cross-site-scripting-xss---stored-xss)
    - [1.18. Cross-Site Scripting (XSS) - Reflected XSS](#118-cross-site-scripting-xss---reflected-xss)
    - [1.19. Cross-Site Scripting (XSS) - DOM-Based XSS](#119-cross-site-scripting-xss---dom-based-xss)
    - [1.20. File Upload Vulnerability - Unrestricted file upload](#120-file-upload-vulnerability---unrestricted-file-upload)
    - [1.21. Denial of Service - Uncaught error handling](#121-denial-of-service---uncaught-error-handling)
    - [1.22. Denial of Service - Regular expression of DoS](#122-denial-of-service---regular-expression-of-dos)
    - [1.23. XML External Entities (XXE)](#123-xml-external-entities-xxe)
    - [1.24. Lack of Resources \& Rate limiting](#124-lack-of-resources--rate-limiting)
  - [2. Sensistive Data Protection](#2-sensistive-data-protection)
    - [2.1. Insecure Cryptography - Weak Algorithm Use](#21-insecure-cryptography---weak-algorithm-use)
    - [2.2. Insecure Cryptography - Padding Oracle](#22-insecure-cryptography---padding-oracle)
    - [2.3. Insecure Cryptography - Insufficiently Protected Credentials](#23-insecure-cryptography---insufficiently-protected-credentials)
    - [2.4. Insecure Cryptography - Insecure Randomess](#24-insecure-cryptography---insecure-randomess)
    - [2.5. Insecure Cryptography - Exposed Key](#25-insecure-cryptography---exposed-key)
    - [2.6. Sensitive Data Storage - Plain Text Storage of Sensitive information](#26-sensitive-data-storage---plain-text-storage-of-sensitive-information)
    - [2.7. Insufficient Transport Layer Protection - Unprotected transport of credentials](#27-insufficient-transport-layer-protection---unprotected-transport-of-credentials)
  - [3. Authentication and access control](#3-authentication-and-access-control)
    - [3.1. Authentication - Forceful browsing](#31-authentication---forceful-browsing)
    - [3.2. Authentication - Improper authentication](#32-authentication---improper-authentication)
    - [3.3. Authentication - Insecure password change function](#33-authentication---insecure-password-change-function)
    - [3.4. Authentication - Insecure password reset function](#34-authentication---insecure-password-reset-function)
    - [3.5. Authentication - Insecure anti-automation](#35-authentication---insecure-anti-automation)
    - [3.6. Authentication - Account enumeration](#36-authentication---account-enumeration)
    - [3.7. Authentication - Weak password policy](#37-authentication---weak-password-policy)
    - [3.8. Session Handling - Cross-site Request Forgery (CSRF)](#38-session-handling---cross-site-request-forgery-csrf)
    - [3.9. Session Handling - Exposed session tokens](#39-session-handling---exposed-session-tokens)
    - [3.10. Session Handling - Insufficient session expiration](#310-session-handling---insufficient-session-expiration)
    - [3.11. Session Handling - Session fixation](#311-session-handling---session-fixation)
    - [3.12. Access Control - Insecure direct object reference](#312-access-control---insecure-direct-object-reference)
    - [3.13. Access Control - Missing function level access](#313-access-control---missing-function-level-access)
    - [3.14. Access Control - Using input from untrusted sources](#314-access-control---using-input-from-untrusted-sources)
    - [3.15. Server-side request forgery (SSRF)](#315-server-side-request-forgery-ssrf)
    - [3.16. Mass assignment](#316-mass-assignment)
  - [4. Insecure Developement Practices](#4-insecure-developement-practices)
    - [4.1. Business Logic - Insufficient validation](#41-business-logic---insufficient-validation)
    - [4.2. Business Logic - Logical error](#42-business-logic---logical-error)
    - [4.3. Improper Assets Management](#43-improper-assets-management)
    - [4.4. Information Exposure - Debug information](#44-information-exposure---debug-information)
    - [4.5. Information Exposure - Error details](#45-information-exposure---error-details)
    - [4.6. Information Exposure - Sensitive data exposure](#46-information-exposure---sensitive-data-exposure)
    - [4.7. Insufficient logging and monitoring](#47-insufficient-logging-and-monitoring)
    - [4.8. Side channel vulnerability - timing attack](#48-side-channel-vulnerability---timing-attack)
    - [4.9. Vulnerable Components - Using components from untrusted source](#49-vulnerable-components---using-components-from-untrusted-source)
    - [4.10. Vulnerable Components - Using known vulnerable components](#410-vulnerable-components---using-known-vulnerable-components)
  - [5. Security Misconfiguration](#5-security-misconfiguration)
    - [5.1. Security Misconfiguration - Clickjacking](#51-security-misconfiguration---clickjacking)
    - [5.2. Security Misconfiguration - Debug features enabled](#52-security-misconfiguration---debug-features-enabled)
    - [5.3. Security Misconfiguration - Disabled security features](#53-security-misconfiguration---disabled-security-features)
    - [5.4. Security Misconfiguration - Information exposure](#54-security-misconfiguration---information-exposure)
    - [5.5. Security Misconfiguration - Improper permissions](#55-security-misconfiguration---improper-permissions)

## 1. Data handling

### 1.1 Injection Flaws - Code injection

- General term given to vulnerabilities that allow a user to inject code that gets interpreted and executed by the application.
- Code injection is limited to the capabilities of the injected language. It can happen both on the server and client side.
- To prevent:
  - Should never trust user input.
  - User parameterized queries and apply least privilege, such as a read only user on both the client and the server side.
  - Apply application-wide filters or sanitization on all user provided input through filtering, encoding, allowlist validation.
  - If possible, don't let functions execute or interpret user input directly.

### 1.2. Injection Flaws - CRLF injection

- CRLF refers to carriage return and line feed, which are used for line termination.
- Use cases:
  - Log splitting: The attacker inserts an end of line character and an extra line to falsify the log file entries in order to deceive the system administrators by hiding other attacks.
  - HTTP response splitting: CRLF injection is used to add HTTP headers to the HTTP response and, for example, perform an XSS attack that leads to information disclosure.
- To prevent:
  - Never trust user input.
  - Implement applicatio-wide filters.
  - Properly sanitizing user inputs and performing encoding on the outputs can prevent this type of attack.
  - Remember to consider GET and POST parameters, Cookies and other HTTP headers.
  - Apply HTML encoding to anything sent back to the browser.

### 1.3. Injection Flaws - LDAP injection

- A vulnerability by which an attacker can influence back-end LDAP queries by injecting malicious LDAP statements, via user controllable input.
- To prevent:
  - User input that being used as part of an LDAP query should be sanitized first.
  - Always use framework provided when available and make of escaped variables in LDAP queries.
  - Use LDAP injection resistant frameworks, automatic LDAP encoding, and framework provided functions where possible.
  - Also, perform validation through an allowlist.
  - Minimize LDAP binding account privilleges by using the Least privilege principle.

### 1.4. Injection Flaws - NoSQL injection

- Occur when an attacker is able to inject malicious code in a NoSQL database.
- Typically done through JSON and JS code.
- To prevent:
  - Input should be JS escaped or validated before being used to query the database.
  - Apply allowlist validation on all user input, including GET and POST parameters, Cookies and other HTTP headers.
  - This ensures that all input is checked against an allowlist of input parameters before being processed.
  - Use a database ORM instead of raw queries.
  - Always validate input parameters.
  - Always apply the Least privilege principle.

### 1.5. Injection Flaws - Path travesal

- Local file inclusion, or LFI, is a vulnerability that allows files hosted on the server to be included and potentially, executed.
- Using Path travesal, files located outside of the current folder can be accessed.
- To prevent:
  - Never directly pass user input to "file include" commands. Use an indirect reference map instead.
  - Apply green-list validation against all user controllable input, including form parameters, cookies and HTTP headers.
  - Remember to pay special attention to '../' or encoded variants in user input.

### 1.6. Injection Flaws - Remote file inclusion

- That allows files hosted on another server to be included and executed.
- To prevent:
  - Never directly pass user input to "file include" commands. Use an indirect reference map instead.
  - Apply green-list validation against all user controllable input, including form parameters, cookies and HTTP headers.

### 1.7. Injection Flaws - Resource injection

- Occurs when an attacker is able to control and manipulate the resource identifiers used by an application.

### 1.8. Injection Flaws - OS command injection

- A vulnerability that allow allows arbitrary commands to be executed on the operating system of the application.

### 1.9. Injection Flaws - SQL injection

- Occurs when an attacker is able to inject SQL queries via the input data of an application.

### 1.10. Injection Flaws - Log forging

- Log files form a history of events or transactions in an application. Log forging vulnerability happens when unvalidated user input is written into log files.
- To prevent:
  - Ensure there is both server- and client-side input validation.

### 1.11. Injection - Local file inclusion

- See Path traversal.

### 1.12. Email injection

- Email header injections are where users are able to craft parameters that cause additional mail headers to be added, when constructing the mail.
- To prevent:
  - Developers should never trust user input
  - Apply filters on all user-provided input from GET and POST parameters, Cookies and other HTTP headers.
  - Apply an allowlist input validation. Libraries often available for this in different frameworks.

### 1.13. Injection Flaws - Deserialization of unstrusted data

- Serialization is when data structures or object states are translated into a format that can be stored.
- Desialization is the opposite. Insecure deserialization occurs when untrusted data is used to abuse the logic flow of an application execute arbitrary code or inflict a Denial of service (DoS) when it is being deserialized.
- SQL injection, cross-site scripting or even remote code execution could result due to insecure deserialization.
- To prevent:
  - Sanitize the data of a serialized object as untrusted user input through filtering or validation.
  - Implement integrity checks such as digital signatures on any serialized object. This will prevent tampering.
  - Isolate and run code that deserializes in a low privilege environment.

### 1.14. Injection Flaws - CSS injection

- Occurs when arbitrary CSS code is injected into a trusted website, which is then rendered in the victim's browser.
- To prevent:
  - Utilize context-dependent sanitization.
  - Consider using a allowlist to prevent attackers from loading arbitrary style sheets.
  - Reducec risk by not allowing users to customize the style of their personal page with CSS.
  - Implement Content Security Policy.
  - Sanitize for html tags such as style.

### 1.15. Injection Flaws - XPath and XML injection

- Are attacks that target XML data stores by injecting malicious XML and XPath code into user controllable input.
- To prevent:
  - Always use a parameterized XPath interface.
  - Sanitize all user input used in XPath expressions from special characters.

### 1.16. Unvalidated redirects and forwards

- Allows trusted websites to be tricked into redirecting users to a malicious website or, tricked into using forwad values to access unauthorized pages.
- To prevent:
  - Avoid redirects and forwads unless absolutely necessary.
  - Don't use user parameters as destination of a redirection or forward.
  - If parameters must be used, validate the supplied value and ensure it is authorized for the user.

### 1.17. Cross-Site Scripting (XSS) - Stored XSS

- An attacker submits a blog post containing a malicious script on a vulnerable site. The script will redirect users reading the blog post to a hostile site.

### 1.18. Cross-Site Scripting (XSS) - Reflected XSS

- An attacker sends an email to a victim. It contains a link to a vulnerable "forgot password" page, with a malicious script included in the URL.

### 1.19. Cross-Site Scripting (XSS) - DOM-Based XSS

- Xss occurs when an adversary can inject malicious scripts into a trusted website. These scripts are then executed by the client's browser without the knowledge of the user.
- DOM-Based XSS, a subset of client XSS, is a vulnerability where developers introduce XSS on the client.

### 1.20. File Upload Vulnerability - Unrestricted file upload

- Some applications allow users to upload their own files. If there are no limitations on the uploaded file name, type or size, the unrestricted file upload could cause problems.
- To prevent:
  - Apply allowlist validation on file names and extensions.
  - Remove special characters from filenames and limit the length to a fixed amount of characters.
  - Only allow particular extensions. Also, save with the detected file extension, not with the original extension.
  - Scan uploaded files for malicious content
  - Use Mime type detection
  - Store uploaded files in a private directory without execution privileges
  - Enforce minimum and maximum file size limits
  - Remove EXIF data
  - Store files with randomly generated file names, keeping a table mapping to the original names

### 1.21. Denial of Service - Uncaught error handling

- Uncaught errors can cause the program to crash and bring it to an unknown state.
- To prevent:
  - Use error handling througout the whole program

### 1.22. Denial of Service - Regular expression of DoS

- Exploits Regular expression implementations. This regex operation could consume a majority of the server resources. Which causes the server to respond slower.
- To prevent:
  - Never allow user input as a part of a regular expression unless the input has been validated.
  - Perform reviews of regular expressions that are being used in an application.
  - Keep in mind that the regular expressions can be abused when they contain one or more of the following or similar combinations...

### 1.23. XML External Entities (XXE)

- Can be used on web applications that parse XML input. An attacker able to submit XML, can make use of references to external entities.
- To prevent:
  - Apply application-wide filters or sanitization on all user-provided input. Consider GET and POST parameters, Cookies and other HTTP headers.
  - Always apply allowlist input validation.
  - XML parses should disable support for external entities, or DTDs, completely. Check framework specific settings to do this.

### 1.24. Lack of Resources & Rate limiting

- All APIs have limited resources and are being called by multiple clients simultaneously. The risk occurs when the API is unable to effectively limit the number of requests or deliverables handled in a given time period.
- To prevent:
  - Exection timeouts
  - Maximum allocable memory
  - The number of processes permitted within a defined timeframe
  - Maximum number of file descriptors
  - Maximum number of requests allowed per client
  - The number of records per page which can be returned per request

## 2. Sensistive Data Protection

### 2.1. Insecure Cryptography - Weak Algorithm Use

### 2.2. Insecure Cryptography - Padding Oracle

- An attacker is able to decrypt information, without knowing the encryption key.
- If an attacker can determine whether a given encrypted text has valid padding when it is decrypted, this can result in cracking CBC based symmetric encryption without needing the key.
- To prevent:
  - Use GCM/No padding rather than CBC padding mode.
  - Catch all decryption errors and return generic messages instead of reporting specific padding errors.
  - Implement Encrypt-then-MAC.
  - Limit requests from the same source.

### 2.3. Insecure Cryptography - Insufficiently Protected Credentials

### 2.4. Insecure Cryptography - Insecure Randomess

- A situation where predictable values ("Seeds") are generated in context requiring unpredictability.
- To prevent:
  - Use Crypography Secure Pseudo-Random Number Generator.
  - Always select well-tested implementation with adequate, random and unpredictable seed lengths.

### 2.5. Insecure Cryptography - Exposed Key

- A developer can expose keys by:
  - Hardcoding the key within the code base
  - Saving the key in a publicly accessible folder on the server
  - Adding they key to the logs or error messages
- To avoid:
  - Store encryption keys in the env vars or a secure keystore.

### 2.6. Sensitive Data Storage - Plain Text Storage of Sensitive information

- To prevent:
  - Encrypt data using transport and at rest, using the latest encryption algorithms
  - Encrypt all data in transit with secure protocols such as TLS
  - Don't store sensitive data unnecessarily
  - Use a strong hashing or encryption algorithm where applicable
  - When using a hasing algorithm be sure to use a salt and a pepper
  - Disable caching of sensitive data

### 2.7. Insufficient Transport Layer Protection - Unprotected transport of credentials

- To prevent:
  - Use strong protocols in TLS for all login pages
  - Ensure strong ciphers

## 3. Authentication and access control

### 3.1. Authentication - Forceful browsing

- Occurs when access is allowed by default.
- Attackers can take advantage of predictable identifiers and naming conventions to discover hidden web pages and links even without authentication.
- To prevent:
  - Ensure all relevant pages, routes and endpoints require proper authentication and access checks
  - Verify that all endpoints, routes and pages consistently follow business requirements and rules

### 3.2. Authentication - Improper authentication

- Occurs when an application improperly verifies the identity of a user. As a result, this can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information.
- To avoid:
  - Beware of insufficient, incorrect or missing authentication checks that may allow a user to access functionality without supplying correct credentials.
  - Don't expose session IDs in the URL
  - Implement multi-factor authentication
  - Don't use user IDs or predictable sequential values as session IDs. Instead, use a secure server-side session manager that generates a random session ID

### 3.3. Authentication - Insecure password change function

- An authentication vulnerability that affects users who need to create a new password for any reason, through the self-service 'Change password' function
- To prevent:
  - Carefully inspect password reset changes
  - Ensure password changes require identity verification
  - Require users to enter their current password along with the new password
  - Check that the user ID is not being included in the request and that the application is not using this value to select the user for whom the password change will occur
  - Ensure that pages which allow administrators to change user passwords require appropriate privileges to use the functionality

### 3.4. Authentication - Insecure password reset function

- Make it possible for unauthorized password changes to occur.
- To prevent:
  - Carefully review the entire password reset flow
  - Try to identify if the user's identity is being appropriately verified
  - Check that any tokens used are sufficiently long and securely randomized in order to prevent brute force attacks
  - Check that the server does not leak information that could allow an attacker determine the token without access to the email

### 3.5. Authentication - Insecure anti-automation

- Occurs when parts of the application, such as login forms, polls, or comment forms can be triggered using automated scripting techniques.
- To prevent:
  - Use techniques to verify human interaction, such as CAPTCHAS
  - CAPTCHAS could be a distored text inside an image, an mathematical calculation, audio question or a logic puzzle
  - The number of consecutive requests from the same source could be limited to avoid brute forcing. Or alternatively, use account lockout

### 3.6. Authentication - Account enumeration

- An attacker tries to guess existing account names by submitting comon login names on the login page.
  - Username doesn't exist -> "Account does not exist".
  - User does exist -> "Wrong password".
- Implementing strong authentication controls are required to protect against username enumeration

### 3.7. Authentication - Weak password policy

- A weak password policy allows users to create a poor password for their account.
- A poor password allows for hackers to perform dictionary attacks or brute-force attacks.
  - Brute-force attack: trial-and-error method used to obtain information such as user passwords.
  - Dictionary attack: a brute-force variant where the hacker uses a dictionary of common words to break the password

### 3.8. Session Handling - Cross-site Request Forgery (CSRF)

- Occurs when a third-party is able to trick a user's web browser into performing actions on a site where the user is currently authenticated.
- To prevent:
  - Should ensure state changing actions are protected with a CSRF token - a long, unique and random value that is linked to the user and session and often provided by the programming framework.
  - CSRF token should be added as a hidden fields to forms and checked by the server when submitted

### 3.9. Session Handling - Exposed session tokens

- A vulnerability in which the unique identifier for a user's session is accessible to a hacker or third party.
- Occurs when an application is storing the session in a publicity accessible parameter or an unprotected cookie.
- To avoid:
  - Store session identifier in a secure HTTP cookie
  - Link the session to another form of identifiable data on the server-side, such as IP Address or User-Agent
  - Revoke the session validity in the event of an identity mismatch
  - Require password confirmation for any potentially sensitive account operations

### 3.10. Session Handling - Insufficient session expiration

- A vulnerability in which the lifespan for the user session's token persists for longer than it should.
- If a session token remains valid for longer than it is needed, it increases the risk of the session being leaked or taken over by a malicious person or script.
- Occur when an application is not setting a time-out on session identifiers, or the application might not be clearing old session identifiers.
- To avoid:
  - Time-out the session after a long period of inactivity
  - Invalidate the session in the event of an identity mismatch
  - Require password confirmation for any potentially sensitive operations

### 3.11. Session Handling - Session fixation

- A hacking technique that explores limitations in the application’s Session ID (SID) management. While authenticating a user, the application doesn’t assign a new SID, making it possible to use an existing SID for the attack.
- This attack consists of:
  - Obtaining a valid Session ID (SID)
  - Tricking the victim into authenticating himself with aforementioned SID
  - Using the SID to impersonate the victim in the web session
- To prevent:
  - Invalidate any existing session identifiers prior to authorizing new sessions
  - Timeout user sessions to limit the malicious attacker's window of opportunity
  - Do not include SIDs in URLs. It's an unsafe practice

### 3.12. Access Control - Insecure direct object reference

- Allows an attacker to bypass authorization checks in order to gain access to protected resources.
- To prevent:
  - Prevent attackers from directly targeting unauthorized resources by using per user, or per session, indirect references instead
  - Implement access control checks
  - Never rely on user-defined input parameters
  - Always rely on server-side session information
  - All private pages should be protected using an authorization mechanism
  - No two separate pieces of code should verify if an account belongs to a certain user

### 3.13. Access Control - Missing function level access

- Occurs when users can perform functions that they are not authorized for, or when resources can be accessed by unauthorized users.
- To prevent:
  - Protect all business functions using a role based authorization mechanism, implemented on the server side
  - Authorization should be applied using centralized routines either provided by the framework or easy to use external modules
  - Always deny access by default
  - Implement functional access control on the server, never the client

### 3.14. Access Control - Using input from untrusted sources

- Happens in applications that use input values to complete the authorization processes that determine what data users can access and manipulate.
- Sometimes developers don't realize that attackers can modify input values such as cookies, local storage, and hidden form fields.
- To prevent:
  - Review any potential areas where an untrusted input could potentially enter an application
  - Use a trusted framework in the application's architecture that prevents this weakness from occuring
  - If possible, try to avoid relying on any type of user submitted input in the authentication process

### 3.15. Server-side request forgery (SSRF)

- A vulnerability in which the server can be made to perform a request on the hacker's behalf
- Occurs when an application is not restricting the location and type of resources it can access
- To avoid:
  - Restrict requests made by the server, to whitelisted locations whenever possible
  - Verify that the requested file type matches that which is expected
  - Display a generic error in the event of failure

### 3.16. Mass assignment

- A vulnerability in which API endpoints do not restrict which properties of their associated object can be modified by the user.
- Occur when the object represented within the HTTP request is bound directly to the data model used for storage, but fails to distinguish between fields that should be assignable and immutable.
- To prevent:
  - Parse the request values rather than binding directly to an object
  - Use a reduced Data Transfer Object rather than binding directly to an object
  - Ensure that sensitive properties are blacklisted or onl safe properties are whitelisted for direct object binding

## 4. Insecure Developement Practices

### 4.1. Business Logic - Insufficient validation

- The insufficient validation of input parameters could let attackers send in data that allows them to bypass security procedures, gain access to restricted information.

### 4.2. Business Logic - Logical error

- Flaws allow attackers to manipulate the business logic of a web application to their advantage.
- To prevent:
  - Business rules should be clearly defined and checked against during the different development phases of the application including design, implementation and testing.
  - Use threat modelling to help identify design flaws.
  - Documenting the design of the application is important.
  - Using data/transaction flow diagrams is recommended
  - Design assumptions should be clearly stated
  - Make the application's design resistant to absue

### 4.3. Improper Assets Management

- Attackers are able to take advantage of outdated, incomplete or undocumented API behaviour.
- To prevent:
  - Ensure that Production data and datastores are kept separate from Development and Staging environments
  - Implement additional security controls such as firewalls, to prevent unintended access to sensitive or weakened environments
  - Fully document the endpoints and error states that exist within the API

### 4.4. Information Exposure - Debug information

- To prevent:
  - Secure settings should be applied to both the application and server.

### 4.5. Information Exposure - Error details

- Happens when users receive an error in the application, and too many details are displayed about why that error has occured.

### 4.6. Information Exposure - Sensitive data exposure

### 4.7. Insufficient logging and monitoring

- The lack of recording proper historical information about events that happened inside an application.
- To prevent:
  - Ensure all failures are properly logged with sufficient user context
  - Log entries should be held for a sufficient time
  - Ensure that logs are generated in a format that can be easily consumed by a centralized log management solution
  - Ensure high-value transactions have an audit trail with integrity controls to prevent tampering or deletion, such as append-only database tables or similar
  - Make sure you have effective monitoring and alerting

### 4.8. Side channel vulnerability - timing attack

### 4.9. Vulnerable Components - Using components from untrusted source

### 4.10. Vulnerable Components - Using known vulnerable components

## 5. Security Misconfiguration

### 5.1. Security Misconfiguration - Clickjacking

- A form of attack where a user is tricked into clicking something other than they intended.
- To prevent:
  - Developers should use HTTP response headers that restrict framing (`X-Frame-Options`, `Content-Security-Policy`)

### 5.2. Security Misconfiguration - Debug features enabled

- Features help developers know the internal state of an application while investigating the cause of errors.

### 5.3. Security Misconfiguration - Disabled security features

- Features that can help protect against hackers have been deactivated.

### 5.4. Security Misconfiguration - Information exposure

- Occurs when security issues arise as a result of insecure default settings or overriding the server or application software options with insecure configuration options.

### 5.5. Security Misconfiguration - Improper permissions

- Give unintended permissions to users, directories, files, sensitive server data, or other objects.
